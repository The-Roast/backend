{"ast":null,"code":"const readFromBlobOrFile = blob => new Promise((resolve, reject) => {\n  const fileReader = new FileReader();\n  fileReader.onload = () => {\n    resolve(fileReader.result);\n  };\n  fileReader.onerror = _ref => {\n    let {\n      target: {\n        error: {\n          code\n        }\n      }\n    } = _ref;\n    reject(Error(`File could not be read! Code=${code}`));\n  };\n  fileReader.readAsArrayBuffer(blob);\n});\n\n// eslint-disable-next-line\nexport const fetchFile = async _data => {\n  let data = _data;\n  if (typeof _data === 'undefined') {\n    return new Uint8Array();\n  }\n  if (typeof _data === 'string') {\n    /* From base64 format */\n    if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) {\n      data = atob(_data.split(',')[1]).split('').map(c => c.charCodeAt(0));\n      /* From remote server/URL */\n    } else {\n      const res = await fetch(new URL(_data, import.meta.url).href);\n      data = await res.arrayBuffer();\n    }\n    /* From Blob or File */\n  } else if (_data instanceof File || _data instanceof Blob) {\n    data = await readFromBlobOrFile(_data);\n  }\n  return new Uint8Array(data);\n};","map":{"version":3,"names":["readFromBlobOrFile","blob","Promise","resolve","reject","fileReader","FileReader","onload","result","onerror","_ref","target","error","code","Error","readAsArrayBuffer","fetchFile","_data","data","Uint8Array","test","atob","split","map","c","charCodeAt","res","fetch","URL","import","meta","url","href","arrayBuffer","File","Blob"],"sources":["/Users/michaelli/Desktop/the-roast/frontend/node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js"],"sourcesContent":["const readFromBlobOrFile = (blob) => (\n  new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.onerror = ({ target: { error: { code } } }) => {\n      reject(Error(`File could not be read! Code=${code}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n  })\n);\n\n// eslint-disable-next-line\nexport const fetchFile = async (_data) => {\n  let data = _data;\n  if (typeof _data === 'undefined') {\n    return new Uint8Array();\n  }\n\n  if (typeof _data === 'string') {\n    /* From base64 format */\n    if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) {\n      data = atob(_data.split(',')[1])\n        .split('')\n        .map((c) => c.charCodeAt(0));\n    /* From remote server/URL */\n    } else {\n      const res = await fetch(new URL(_data, import.meta.url).href);\n      data = await res.arrayBuffer();\n    }\n  /* From Blob or File */\n  } else if (_data instanceof File || _data instanceof Blob) {\n    data = await readFromBlobOrFile(_data);\n  }\n\n  return new Uint8Array(data);\n};\n"],"mappings":"AAAA,MAAMA,kBAAkB,GAAIC,IAAI,IAC9B,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;EAC/B,MAAMC,UAAU,GAAG,IAAIC,UAAU,CAAC,CAAC;EACnCD,UAAU,CAACE,MAAM,GAAG,MAAM;IACxBJ,OAAO,CAACE,UAAU,CAACG,MAAM,CAAC;EAC5B,CAAC;EACDH,UAAU,CAACI,OAAO,GAAGC,IAAA,IAAqC;IAAA,IAApC;MAAEC,MAAM,EAAE;QAAEC,KAAK,EAAE;UAAEC;QAAK;MAAE;IAAE,CAAC,GAAAH,IAAA;IACnDN,MAAM,CAACU,KAAK,CAAE,gCAA+BD,IAAK,EAAC,CAAC,CAAC;EACvD,CAAC;EACDR,UAAU,CAACU,iBAAiB,CAACd,IAAI,CAAC;AACpC,CAAC,CACF;;AAED;AACA,OAAO,MAAMe,SAAS,GAAG,MAAOC,KAAK,IAAK;EACxC,IAAIC,IAAI,GAAGD,KAAK;EAChB,IAAI,OAAOA,KAAK,KAAK,WAAW,EAAE;IAChC,OAAO,IAAIE,UAAU,CAAC,CAAC;EACzB;EAEA,IAAI,OAAOF,KAAK,KAAK,QAAQ,EAAE;IAC7B;IACA,IAAI,wCAAwC,CAACG,IAAI,CAACH,KAAK,CAAC,EAAE;MACxDC,IAAI,GAAGG,IAAI,CAACJ,KAAK,CAACK,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAC7BA,KAAK,CAAC,EAAE,CAAC,CACTC,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC;MAChC;IACA,CAAC,MAAM;MACL,MAAMC,GAAG,GAAG,MAAMC,KAAK,CAAC,IAAIC,GAAG,CAACX,KAAK,EAAEY,MAAM,CAACC,IAAI,CAACC,GAAG,CAAC,CAACC,IAAI,CAAC;MAC7Dd,IAAI,GAAG,MAAMQ,GAAG,CAACO,WAAW,CAAC,CAAC;IAChC;IACF;EACA,CAAC,MAAM,IAAIhB,KAAK,YAAYiB,IAAI,IAAIjB,KAAK,YAAYkB,IAAI,EAAE;IACzDjB,IAAI,GAAG,MAAMlB,kBAAkB,CAACiB,KAAK,CAAC;EACxC;EAEA,OAAO,IAAIE,UAAU,CAACD,IAAI,CAAC;AAC7B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}