{"ast":null,"code":"const {\n  defaultArgs,\n  baseOptions\n} = require('./config');\nconst parseArgs = require('./utils/parseArgs');\nconst {\n  defaultOptions,\n  getCreateFFmpegCore\n} = require('./node');\nconst {\n  version\n} = require('../package.json');\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\nmodule.exports = function () {\n  let _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    log: optLog,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let runReject = null;\n  let running = false;\n  let customLogger = () => {};\n  let logging = optLog;\n  let progress = optProgress;\n  let duration = 0;\n  let frames = 0;\n  let readFrames = false;\n  let ratio = 0;\n  const detectCompletion = message => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      runReject = null;\n      running = false;\n    }\n  };\n  const log = (type, message) => {\n    customLogger({\n      type,\n      message\n    });\n    if (logging) {\n      console.log(`[${type}] ${message}`);\n    }\n  };\n  const ts2sec = ts => {\n    const [h, m, s] = ts.split(':');\n    return parseFloat(h) * 60 * 60 + parseFloat(m) * 60 + parseFloat(s);\n  };\n  const parseProgress = (message, prog) => {\n    if (typeof message === 'string') {\n      if (message.startsWith('  Duration')) {\n        const ts = message.split(', ')[0].split(': ')[1];\n        const d = ts2sec(ts);\n        prog({\n          duration: d,\n          ratio\n        });\n        if (duration === 0 || duration > d) {\n          duration = d;\n          readFrames = true;\n        }\n      } else if (readFrames && message.startsWith('    Stream')) {\n        const match = message.match(/([\\d.]+) fps/);\n        if (match) {\n          const fps = parseFloat(match[1]);\n          frames = duration * fps;\n        } else {\n          frames = 0;\n        }\n        readFrames = false;\n      } else if (message.startsWith('frame') || message.startsWith('size')) {\n        const ts = message.split('time=')[1].split(' ')[0];\n        const t = ts2sec(ts);\n        const match = message.match(/frame=\\s*(\\d+)/);\n        if (frames && match) {\n          const f = parseFloat(match[1]);\n          ratio = Math.min(f / frames, 1);\n        } else {\n          ratio = t / duration;\n        }\n        prog({\n          ratio,\n          time: t\n        });\n      } else if (message.startsWith('video:')) {\n        prog({\n          ratio: 1\n        });\n        duration = 0;\n      }\n    }\n  };\n  const parseMessage = _ref => {\n    let {\n      type,\n      message\n    } = _ref;\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: message => parseMessage({\n          type: 'fferr',\n          message\n        }),\n        print: message => parseMessage({\n          type: 'ffout',\n          message\n        }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined' || typeof WorkerGlobalScope !== 'undefined') {\n            if (typeof wasmPath !== 'undefined' && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n            if (typeof workerPath !== 'undefined' && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n          return prefix + path;\n        }\n      });\n      ffmpeg = Core.cwrap(options.mainName || 'proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = function () {\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve, reject) => {\n        const args = [...defaultArgs, ..._args].filter(s => s.length !== 0);\n        runResolve = resolve;\n        runReject = reject;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = function (method) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    log('info', `run FS.${method} ${args.map(arg => typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      // if there's any pending runs, reject them\n      if (runReject) {\n        runReject('ffmpeg has exited');\n      }\n      running = false;\n      try {\n        Core.exit(1);\n      } catch (err) {\n        log(err.message);\n        if (runReject) {\n          runReject(err);\n        }\n      } finally {\n        Core = null;\n        ffmpeg = null;\n        runResolve = null;\n        runReject = null;\n      }\n    }\n  };\n  const setProgress = _progress => {\n    progress = _progress;\n  };\n  const setLogger = _logger => {\n    customLogger = _logger;\n  };\n  const setLogging = _logging => {\n    logging = _logging;\n  };\n  log('info', `use ffmpeg.wasm v${version}`);\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS\n  };\n};","map":{"version":3,"names":["defaultArgs","baseOptions","require","parseArgs","defaultOptions","getCreateFFmpegCore","version","NO_LOAD","Error","module","exports","_options","arguments","length","undefined","log","optLog","logger","progress","optProgress","options","Core","ffmpeg","runResolve","runReject","running","customLogger","logging","duration","frames","readFrames","ratio","detectCompletion","message","type","console","ts2sec","ts","h","m","s","split","parseFloat","parseProgress","prog","startsWith","d","match","fps","t","f","Math","min","time","parseMessage","_ref","load","createFFmpegCore","corePath","workerPath","wasmPath","mainScriptUrlOrBlob","printErr","print","locateFile","path","prefix","window","WorkerGlobalScope","endsWith","cwrap","mainName","isLoaded","run","_len","_args","Array","_key","join","Promise","resolve","reject","args","filter","FS","method","_len2","_key2","map","arg","ret","e","exit","err","setProgress","_progress","setLogger","_logger","setLogging","_logging"],"sources":["/Users/michaelli/Desktop/the-roast/frontend/node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js"],"sourcesContent":["const { defaultArgs, baseOptions } = require('./config');\nconst parseArgs = require('./utils/parseArgs');\nconst { defaultOptions, getCreateFFmpegCore } = require('./node');\nconst { version } = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: optLog,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let runReject = null;\n  let running = false;\n  let customLogger = () => {};\n  let logging = optLog;\n  let progress = optProgress;\n  let duration = 0;\n  let frames = 0;\n  let readFrames = false;\n  let ratio = 0;\n\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      runReject = null;\n      running = false;\n    }\n  };\n  const log = (type, message) => {\n    customLogger({ type, message });\n    if (logging) {\n      console.log(`[${type}] ${message}`);\n    }\n  };\n  const ts2sec = (ts) => {\n    const [h, m, s] = ts.split(':');\n    return (parseFloat(h) * 60 * 60) + (parseFloat(m) * 60) + parseFloat(s);\n  };\n  const parseProgress = (message, prog) => {\n    if (typeof message === 'string') {\n      if (message.startsWith('  Duration')) {\n        const ts = message.split(', ')[0].split(': ')[1];\n        const d = ts2sec(ts);\n        prog({ duration: d, ratio });\n        if (duration === 0 || duration > d) {\n          duration = d;\n          readFrames = true;\n        }\n      } else if (readFrames && message.startsWith('    Stream')) {\n        const match = message.match(/([\\d.]+) fps/);\n        if (match) {\n          const fps = parseFloat(match[1]);\n          frames = duration * fps;\n        } else {\n          frames = 0;\n        }\n        readFrames = false;\n      } else if (message.startsWith('frame') || message.startsWith('size')) {\n        const ts = message.split('time=')[1].split(' ')[0];\n        const t = ts2sec(ts);\n        const match = message.match(/frame=\\s*(\\d+)/);\n        if (frames && match) {\n          const f = parseFloat(match[1]);\n          ratio = Math.min(f / frames, 1);\n        } else {\n          ratio = t / duration;\n        }\n        prog({ ratio, time: t });\n      } else if (message.startsWith('video:')) {\n        prog({ ratio: 1 });\n        duration = 0;\n      }\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath,\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined' || typeof WorkerGlobalScope !== 'undefined') {\n            if (typeof wasmPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n            if (typeof workerPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap(options.mainName || 'proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve, reject) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        runReject = reject;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      // if there's any pending runs, reject them\n      if (runReject) {\n        runReject('ffmpeg has exited');\n      }\n      running = false;\n      try {\n        Core.exit(1);\n      } catch (err) {\n        log(err.message);\n        if (runReject) {\n          runReject(err);\n        }\n      } finally {\n        Core = null;\n        ffmpeg = null;\n        runResolve = null;\n        runReject = null;\n      }\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    customLogger = _logger;\n  };\n\n  const setLogging = (_logging) => {\n    logging = _logging;\n  };\n\n  log('info', `use ffmpeg.wasm v${version}`);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}