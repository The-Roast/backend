{"ast":null,"code":"var common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\nvar Takehiro = require('./Takehiro.js');\nvar Tables = require('./Tables.js');\nvar Encoder = require('./Encoder.js');\nvar LameInternalFlags = require('./LameInternalFlags.js');\nBitStream.EQ = function (a, b) {\n  return Math.abs(a) > Math.abs(b) ? Math.abs(a - b) <= Math.abs(a) * 1e-6 : Math.abs(a - b) <= Math.abs(b) * 1e-6;\n};\nBitStream.NEQ = function (a, b) {\n  return !BitStream.EQ(a, b);\n};\nfunction BitStream() {\n  var Lame = require('./Lame.js');\n  var self = this;\n  var CRC16_POLYNOMIAL = 0x8005;\n\n  /*\n   * we work with ints, so when doing bit manipulation, we limit ourselves to\n   * MAX_LENGTH-2 just to be on the safe side\n   */\n  var MAX_LENGTH = 32;\n\n  //GainAnalysis ga;\n  //MPGLib mpg;\n  //Version ver;\n  //VBRTag vbr;\n  var ga = null;\n  var mpg = null;\n  var ver = null;\n  var vbr = null;\n\n  //public final void setModules(GainAnalysis ga, MPGLib mpg, Version ver,\n  //\tVBRTag vbr) {\n\n  this.setModules = function (_ga, _mpg, _ver, _vbr) {\n    ga = _ga;\n    mpg = _mpg;\n    ver = _ver;\n    vbr = _vbr;\n  };\n\n  /**\n   * Bit stream buffer.\n   */\n  //private byte[] buf;\n  var buf = null;\n  /**\n   * Bit counter of bit stream.\n   */\n  var totbit = 0;\n  /**\n   * Pointer to top byte in buffer.\n   */\n  var bufByteIdx = 0;\n  /**\n   * Pointer to top bit of top byte in buffer.\n   */\n  var bufBitIdx = 0;\n\n  /**\n   * compute bitsperframe and mean_bits for a layer III frame\n   */\n  this.getframebits = function (gfp) {\n    var gfc = gfp.internal_flags;\n    var bit_rate;\n\n    /* get bitrate in kbps [?] */\n    if (gfc.bitrate_index != 0) bit_rate = Tables.bitrate_table[gfp.version][gfc.bitrate_index];else bit_rate = gfp.brate;\n    assert(8 <= bit_rate && bit_rate <= 640);\n\n    /* main encoding routine toggles padding on and off */\n    /* one Layer3 Slot consists of 8 bits */\n    var bytes = 0 | (gfp.version + 1) * 72000 * bit_rate / gfp.out_samplerate + gfc.padding;\n    return 8 * bytes;\n  };\n  function putheader_bits(gfc) {\n    System.arraycopy(gfc.header[gfc.w_ptr].buf, 0, buf, bufByteIdx, gfc.sideinfo_len);\n    bufByteIdx += gfc.sideinfo_len;\n    totbit += gfc.sideinfo_len * 8;\n    gfc.w_ptr = gfc.w_ptr + 1 & LameInternalFlags.MAX_HEADER_BUF - 1;\n  }\n\n  /**\n   * write j bits into the bit stream\n   */\n  function putbits2(gfc, val, j) {\n    assert(j < MAX_LENGTH - 2);\n    while (j > 0) {\n      var k;\n      if (bufBitIdx == 0) {\n        bufBitIdx = 8;\n        bufByteIdx++;\n        assert(bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n        assert(gfc.header[gfc.w_ptr].write_timing >= totbit);\n        if (gfc.header[gfc.w_ptr].write_timing == totbit) {\n          putheader_bits(gfc);\n        }\n        buf[bufByteIdx] = 0;\n      }\n      k = Math.min(j, bufBitIdx);\n      j -= k;\n      bufBitIdx -= k;\n      assert(j < MAX_LENGTH);\n      /* 32 too large on 32 bit machines */\n      assert(bufBitIdx < MAX_LENGTH);\n      buf[bufByteIdx] |= val >> j << bufBitIdx;\n      totbit += k;\n    }\n  }\n\n  /**\n   * write j bits into the bit stream, ignoring frame headers\n   */\n  function putbits_noheaders(gfc, val, j) {\n    assert(j < MAX_LENGTH - 2);\n    while (j > 0) {\n      var k;\n      if (bufBitIdx == 0) {\n        bufBitIdx = 8;\n        bufByteIdx++;\n        assert(bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n        buf[bufByteIdx] = 0;\n      }\n      k = Math.min(j, bufBitIdx);\n      j -= k;\n      bufBitIdx -= k;\n      assert(j < MAX_LENGTH);\n      /* 32 too large on 32 bit machines */\n      assert(bufBitIdx < MAX_LENGTH);\n      buf[bufByteIdx] |= val >> j << bufBitIdx;\n      totbit += k;\n    }\n  }\n\n  /**\n   * Some combinations of bitrate, Fs, and stereo make it impossible to stuff\n   * out a frame using just main_data, due to the limited number of bits to\n   * indicate main_data_length. In these situations, we put stuffing bits into\n   * the ancillary data...\n   */\n  function drain_into_ancillary(gfp, remainingBits) {\n    var gfc = gfp.internal_flags;\n    var i;\n    assert(remainingBits >= 0);\n    if (remainingBits >= 8) {\n      putbits2(gfc, 0x4c, 8);\n      remainingBits -= 8;\n    }\n    if (remainingBits >= 8) {\n      putbits2(gfc, 0x41, 8);\n      remainingBits -= 8;\n    }\n    if (remainingBits >= 8) {\n      putbits2(gfc, 0x4d, 8);\n      remainingBits -= 8;\n    }\n    if (remainingBits >= 8) {\n      putbits2(gfc, 0x45, 8);\n      remainingBits -= 8;\n    }\n    if (remainingBits >= 32) {\n      var version = ver.getLameShortVersion();\n      if (remainingBits >= 32) for (i = 0; i < version.length && remainingBits >= 8; ++i) {\n        remainingBits -= 8;\n        putbits2(gfc, version.charAt(i), 8);\n      }\n    }\n    for (; remainingBits >= 1; remainingBits -= 1) {\n      putbits2(gfc, gfc.ancillary_flag, 1);\n      gfc.ancillary_flag ^= !gfp.disable_reservoir ? 1 : 0;\n    }\n    assert(remainingBits == 0);\n  }\n\n  /**\n   * write N bits into the header\n   */\n  function writeheader(gfc, val, j) {\n    var ptr = gfc.header[gfc.h_ptr].ptr;\n    while (j > 0) {\n      var k = Math.min(j, 8 - (ptr & 7));\n      j -= k;\n      assert(j < MAX_LENGTH);\n      /* >> 32 too large for 32 bit machines */\n\n      gfc.header[gfc.h_ptr].buf[ptr >> 3] |= val >> j << 8 - (ptr & 7) - k;\n      ptr += k;\n    }\n    gfc.header[gfc.h_ptr].ptr = ptr;\n  }\n  function CRC_update(value, crc) {\n    value <<= 8;\n    for (var i = 0; i < 8; i++) {\n      value <<= 1;\n      crc <<= 1;\n      if (((crc ^ value) & 0x10000) != 0) crc ^= CRC16_POLYNOMIAL;\n    }\n    return crc;\n  }\n  this.CRC_writeheader = function (gfc, header) {\n    var crc = 0xffff;\n    /* (jo) init crc16 for error_protection */\n\n    crc = CRC_update(header[2] & 0xff, crc);\n    crc = CRC_update(header[3] & 0xff, crc);\n    for (var i = 6; i < gfc.sideinfo_len; i++) {\n      crc = CRC_update(header[i] & 0xff, crc);\n    }\n    header[4] = byte(crc >> 8);\n    header[5] = byte(crc & 255);\n  };\n  function encodeSideInfo2(gfp, bitsPerFrame) {\n    var gfc = gfp.internal_flags;\n    var l3_side;\n    var gr, ch;\n    l3_side = gfc.l3_side;\n    gfc.header[gfc.h_ptr].ptr = 0;\n    Arrays.fill(gfc.header[gfc.h_ptr].buf, 0, gfc.sideinfo_len, 0);\n    if (gfp.out_samplerate < 16000) writeheader(gfc, 0xffe, 12);else writeheader(gfc, 0xfff, 12);\n    writeheader(gfc, gfp.version, 1);\n    writeheader(gfc, 4 - 3, 2);\n    writeheader(gfc, !gfp.error_protection ? 1 : 0, 1);\n    writeheader(gfc, gfc.bitrate_index, 4);\n    writeheader(gfc, gfc.samplerate_index, 2);\n    writeheader(gfc, gfc.padding, 1);\n    writeheader(gfc, gfp.extension, 1);\n    writeheader(gfc, gfp.mode.ordinal(), 2);\n    writeheader(gfc, gfc.mode_ext, 2);\n    writeheader(gfc, gfp.copyright, 1);\n    writeheader(gfc, gfp.original, 1);\n    writeheader(gfc, gfp.emphasis, 2);\n    if (gfp.error_protection) {\n      writeheader(gfc, 0, 16);\n      /* dummy */\n    }\n\n    if (gfp.version == 1) {\n      /* MPEG1 */\n      assert(l3_side.main_data_begin >= 0);\n      writeheader(gfc, l3_side.main_data_begin, 9);\n      if (gfc.channels_out == 2) writeheader(gfc, l3_side.private_bits, 3);else writeheader(gfc, l3_side.private_bits, 5);\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        var band;\n        for (band = 0; band < 4; band++) {\n          writeheader(gfc, l3_side.scfsi[ch][band], 1);\n        }\n      }\n      for (gr = 0; gr < 2; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          var gi = l3_side.tt[gr][ch];\n          writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);\n          writeheader(gfc, gi.big_values / 2, 9);\n          writeheader(gfc, gi.global_gain, 8);\n          writeheader(gfc, gi.scalefac_compress, 4);\n          if (gi.block_type != Encoder.NORM_TYPE) {\n            writeheader(gfc, 1, 1);\n            /* window_switching_flag */\n            writeheader(gfc, gi.block_type, 2);\n            writeheader(gfc, gi.mixed_block_flag, 1);\n            if (gi.table_select[0] == 14) gi.table_select[0] = 16;\n            writeheader(gfc, gi.table_select[0], 5);\n            if (gi.table_select[1] == 14) gi.table_select[1] = 16;\n            writeheader(gfc, gi.table_select[1], 5);\n            writeheader(gfc, gi.subblock_gain[0], 3);\n            writeheader(gfc, gi.subblock_gain[1], 3);\n            writeheader(gfc, gi.subblock_gain[2], 3);\n          } else {\n            writeheader(gfc, 0, 1);\n            /* window_switching_flag */\n            if (gi.table_select[0] == 14) gi.table_select[0] = 16;\n            writeheader(gfc, gi.table_select[0], 5);\n            if (gi.table_select[1] == 14) gi.table_select[1] = 16;\n            writeheader(gfc, gi.table_select[1], 5);\n            if (gi.table_select[2] == 14) gi.table_select[2] = 16;\n            writeheader(gfc, gi.table_select[2], 5);\n            assert(0 <= gi.region0_count && gi.region0_count < 16);\n            assert(0 <= gi.region1_count && gi.region1_count < 8);\n            writeheader(gfc, gi.region0_count, 4);\n            writeheader(gfc, gi.region1_count, 3);\n          }\n          writeheader(gfc, gi.preflag, 1);\n          writeheader(gfc, gi.scalefac_scale, 1);\n          writeheader(gfc, gi.count1table_select, 1);\n        }\n      }\n    } else {\n      /* MPEG2 */\n      assert(l3_side.main_data_begin >= 0);\n      writeheader(gfc, l3_side.main_data_begin, 8);\n      writeheader(gfc, l3_side.private_bits, gfc.channels_out);\n      gr = 0;\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        var gi = l3_side.tt[gr][ch];\n        writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);\n        writeheader(gfc, gi.big_values / 2, 9);\n        writeheader(gfc, gi.global_gain, 8);\n        writeheader(gfc, gi.scalefac_compress, 9);\n        if (gi.block_type != Encoder.NORM_TYPE) {\n          writeheader(gfc, 1, 1);\n          /* window_switching_flag */\n          writeheader(gfc, gi.block_type, 2);\n          writeheader(gfc, gi.mixed_block_flag, 1);\n          if (gi.table_select[0] == 14) gi.table_select[0] = 16;\n          writeheader(gfc, gi.table_select[0], 5);\n          if (gi.table_select[1] == 14) gi.table_select[1] = 16;\n          writeheader(gfc, gi.table_select[1], 5);\n          writeheader(gfc, gi.subblock_gain[0], 3);\n          writeheader(gfc, gi.subblock_gain[1], 3);\n          writeheader(gfc, gi.subblock_gain[2], 3);\n        } else {\n          writeheader(gfc, 0, 1);\n          /* window_switching_flag */\n          if (gi.table_select[0] == 14) gi.table_select[0] = 16;\n          writeheader(gfc, gi.table_select[0], 5);\n          if (gi.table_select[1] == 14) gi.table_select[1] = 16;\n          writeheader(gfc, gi.table_select[1], 5);\n          if (gi.table_select[2] == 14) gi.table_select[2] = 16;\n          writeheader(gfc, gi.table_select[2], 5);\n          assert(0 <= gi.region0_count && gi.region0_count < 16);\n          assert(0 <= gi.region1_count && gi.region1_count < 8);\n          writeheader(gfc, gi.region0_count, 4);\n          writeheader(gfc, gi.region1_count, 3);\n        }\n        writeheader(gfc, gi.scalefac_scale, 1);\n        writeheader(gfc, gi.count1table_select, 1);\n      }\n    }\n    if (gfp.error_protection) {\n      /* (jo) error_protection: add crc16 information to header */\n      CRC_writeheader(gfc, gfc.header[gfc.h_ptr].buf);\n    }\n    {\n      var old = gfc.h_ptr;\n      assert(gfc.header[old].ptr == gfc.sideinfo_len * 8);\n      gfc.h_ptr = old + 1 & LameInternalFlags.MAX_HEADER_BUF - 1;\n      gfc.header[gfc.h_ptr].write_timing = gfc.header[old].write_timing + bitsPerFrame;\n      if (gfc.h_ptr == gfc.w_ptr) {\n        /* yikes! we are out of header buffer space */\n        System.err.println(\"Error: MAX_HEADER_BUF too small in bitstream.c \\n\");\n      }\n    }\n  }\n  function huffman_coder_count1(gfc, gi) {\n    /* Write count1 area */\n    var h = Tables.ht[gi.count1table_select + 32];\n    var i,\n      bits = 0;\n    var ix = gi.big_values;\n    var xr = gi.big_values;\n    assert(gi.count1table_select < 2);\n    for (i = (gi.count1 - gi.big_values) / 4; i > 0; --i) {\n      var huffbits = 0;\n      var p = 0,\n        v;\n      v = gi.l3_enc[ix + 0];\n      if (v != 0) {\n        p += 8;\n        if (gi.xr[xr + 0] < 0) huffbits++;\n        assert(v <= 1);\n      }\n      v = gi.l3_enc[ix + 1];\n      if (v != 0) {\n        p += 4;\n        huffbits *= 2;\n        if (gi.xr[xr + 1] < 0) huffbits++;\n        assert(v <= 1);\n      }\n      v = gi.l3_enc[ix + 2];\n      if (v != 0) {\n        p += 2;\n        huffbits *= 2;\n        if (gi.xr[xr + 2] < 0) huffbits++;\n        assert(v <= 1);\n      }\n      v = gi.l3_enc[ix + 3];\n      if (v != 0) {\n        p++;\n        huffbits *= 2;\n        if (gi.xr[xr + 3] < 0) huffbits++;\n        assert(v <= 1);\n      }\n      ix += 4;\n      xr += 4;\n      putbits2(gfc, huffbits + h.table[p], h.hlen[p]);\n      bits += h.hlen[p];\n    }\n    return bits;\n  }\n\n  /**\n   * Implements the pseudocode of page 98 of the IS\n   */\n  function Huffmancode(gfc, tableindex, start, end, gi) {\n    var h = Tables.ht[tableindex];\n    var bits = 0;\n    assert(tableindex < 32);\n    if (0 == tableindex) return bits;\n    for (var i = start; i < end; i += 2) {\n      var cbits = 0;\n      var xbits = 0;\n      var linbits = h.xlen;\n      var xlen = h.xlen;\n      var ext = 0;\n      var x1 = gi.l3_enc[i];\n      var x2 = gi.l3_enc[i + 1];\n      if (x1 != 0) {\n        if (gi.xr[i] < 0) ext++;\n        cbits--;\n      }\n      if (tableindex > 15) {\n        /* use ESC-words */\n        if (x1 > 14) {\n          var linbits_x1 = x1 - 15;\n          assert(linbits_x1 <= h.linmax);\n          ext |= linbits_x1 << 1;\n          xbits = linbits;\n          x1 = 15;\n        }\n        if (x2 > 14) {\n          var linbits_x2 = x2 - 15;\n          assert(linbits_x2 <= h.linmax);\n          ext <<= linbits;\n          ext |= linbits_x2;\n          xbits += linbits;\n          x2 = 15;\n        }\n        xlen = 16;\n      }\n      if (x2 != 0) {\n        ext <<= 1;\n        if (gi.xr[i + 1] < 0) ext++;\n        cbits--;\n      }\n      assert((x1 | x2) < 16);\n      x1 = x1 * xlen + x2;\n      xbits -= cbits;\n      cbits += h.hlen[x1];\n      assert(cbits <= MAX_LENGTH);\n      assert(xbits <= MAX_LENGTH);\n      putbits2(gfc, h.table[x1], cbits);\n      putbits2(gfc, ext, xbits);\n      bits += cbits + xbits;\n    }\n    return bits;\n  }\n\n  /**\n   * Note the discussion of huffmancodebits() on pages 28 and 29 of the IS, as\n   * well as the definitions of the side information on pages 26 and 27.\n   */\n  function ShortHuffmancodebits(gfc, gi) {\n    var region1Start = 3 * gfc.scalefac_band.s[3];\n    if (region1Start > gi.big_values) region1Start = gi.big_values;\n\n    /* short blocks do not have a region2 */\n    var bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);\n    bits += Huffmancode(gfc, gi.table_select[1], region1Start, gi.big_values, gi);\n    return bits;\n  }\n  function LongHuffmancodebits(gfc, gi) {\n    var bigvalues, bits;\n    var region1Start, region2Start;\n    bigvalues = gi.big_values;\n    assert(0 <= bigvalues && bigvalues <= 576);\n    var i = gi.region0_count + 1;\n    assert(0 <= i);\n    assert(i < gfc.scalefac_band.l.length);\n    region1Start = gfc.scalefac_band.l[i];\n    i += gi.region1_count + 1;\n    assert(0 <= i);\n    assert(i < gfc.scalefac_band.l.length);\n    region2Start = gfc.scalefac_band.l[i];\n    if (region1Start > bigvalues) region1Start = bigvalues;\n    if (region2Start > bigvalues) region2Start = bigvalues;\n    bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);\n    bits += Huffmancode(gfc, gi.table_select[1], region1Start, region2Start, gi);\n    bits += Huffmancode(gfc, gi.table_select[2], region2Start, bigvalues, gi);\n    return bits;\n  }\n  function writeMainData(gfp) {\n    var gr,\n      ch,\n      sfb,\n      data_bits,\n      tot_bits = 0;\n    var gfc = gfp.internal_flags;\n    var l3_side = gfc.l3_side;\n    if (gfp.version == 1) {\n      /* MPEG 1 */\n      for (gr = 0; gr < 2; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          var gi = l3_side.tt[gr][ch];\n          var slen1 = Takehiro.slen1_tab[gi.scalefac_compress];\n          var slen2 = Takehiro.slen2_tab[gi.scalefac_compress];\n          data_bits = 0;\n          for (sfb = 0; sfb < gi.sfbdivide; sfb++) {\n            if (gi.scalefac[sfb] == -1) continue;\n            /* scfsi is used */\n            putbits2(gfc, gi.scalefac[sfb], slen1);\n            data_bits += slen1;\n          }\n          for (; sfb < gi.sfbmax; sfb++) {\n            if (gi.scalefac[sfb] == -1) continue;\n            /* scfsi is used */\n            putbits2(gfc, gi.scalefac[sfb], slen2);\n            data_bits += slen2;\n          }\n          assert(data_bits == gi.part2_length);\n          if (gi.block_type == Encoder.SHORT_TYPE) {\n            data_bits += ShortHuffmancodebits(gfc, gi);\n          } else {\n            data_bits += LongHuffmancodebits(gfc, gi);\n          }\n          data_bits += huffman_coder_count1(gfc, gi);\n          /* does bitcount in quantize.c agree with actual bit count? */\n          assert(data_bits == gi.part2_3_length + gi.part2_length);\n          tot_bits += data_bits;\n        }\n        /* for ch */\n      }\n      /* for gr */\n    } else {\n      /* MPEG 2 */\n      gr = 0;\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        var gi = l3_side.tt[gr][ch];\n        var i,\n          sfb_partition,\n          scale_bits = 0;\n        assert(gi.sfb_partition_table != null);\n        data_bits = 0;\n        sfb = 0;\n        sfb_partition = 0;\n        if (gi.block_type == Encoder.SHORT_TYPE) {\n          for (; sfb_partition < 4; sfb_partition++) {\n            var sfbs = gi.sfb_partition_table[sfb_partition] / 3;\n            var slen = gi.slen[sfb_partition];\n            for (i = 0; i < sfbs; i++, sfb++) {\n              putbits2(gfc, Math.max(gi.scalefac[sfb * 3 + 0], 0), slen);\n              putbits2(gfc, Math.max(gi.scalefac[sfb * 3 + 1], 0), slen);\n              putbits2(gfc, Math.max(gi.scalefac[sfb * 3 + 2], 0), slen);\n              scale_bits += 3 * slen;\n            }\n          }\n          data_bits += ShortHuffmancodebits(gfc, gi);\n        } else {\n          for (; sfb_partition < 4; sfb_partition++) {\n            var sfbs = gi.sfb_partition_table[sfb_partition];\n            var slen = gi.slen[sfb_partition];\n            for (i = 0; i < sfbs; i++, sfb++) {\n              putbits2(gfc, Math.max(gi.scalefac[sfb], 0), slen);\n              scale_bits += slen;\n            }\n          }\n          data_bits += LongHuffmancodebits(gfc, gi);\n        }\n        data_bits += huffman_coder_count1(gfc, gi);\n        /* does bitcount in quantize.c agree with actual bit count? */\n        assert(data_bits == gi.part2_3_length);\n        assert(scale_bits == gi.part2_length);\n        tot_bits += scale_bits + data_bits;\n      }\n      /* for ch */\n    }\n    /* for gf */\n    return tot_bits;\n  }\n\n  /* main_data */\n\n  function TotalBytes() {\n    this.total = 0;\n  }\n\n  /*\n   * compute the number of bits required to flush all mp3 frames currently in\n   * the buffer. This should be the same as the reservoir size. Only call this\n   * routine between frames - i.e. only after all headers and data have been\n   * added to the buffer by format_bitstream().\n   *\n   * Also compute total_bits_output = size of mp3 buffer (including frame\n   * headers which may not have yet been send to the mp3 buffer) + number of\n   * bits needed to flush all mp3 frames.\n   *\n   * total_bytes_output is the size of the mp3 output buffer if\n   * lame_encode_flush_nogap() was called right now.\n   */\n  function compute_flushbits(gfp, total_bytes_output) {\n    var gfc = gfp.internal_flags;\n    var flushbits, remaining_headers;\n    var bitsPerFrame;\n    var last_ptr, first_ptr;\n    first_ptr = gfc.w_ptr;\n    /* first header to add to bitstream */\n    last_ptr = gfc.h_ptr - 1;\n    /* last header to add to bitstream */\n    if (last_ptr == -1) last_ptr = LameInternalFlags.MAX_HEADER_BUF - 1;\n\n    /* add this many bits to bitstream so we can flush all headers */\n    flushbits = gfc.header[last_ptr].write_timing - totbit;\n    total_bytes_output.total = flushbits;\n    if (flushbits >= 0) {\n      /* if flushbits >= 0, some headers have not yet been written */\n      /* reduce flushbits by the size of the headers */\n      remaining_headers = 1 + last_ptr - first_ptr;\n      if (last_ptr < first_ptr) remaining_headers = 1 + last_ptr - first_ptr + LameInternalFlags.MAX_HEADER_BUF;\n      flushbits -= remaining_headers * 8 * gfc.sideinfo_len;\n    }\n\n    /*\n     * finally, add some bits so that the last frame is complete these bits\n     * are not necessary to decode the last frame, but some decoders will\n     * ignore last frame if these bits are missing\n     */\n    bitsPerFrame = self.getframebits(gfp);\n    flushbits += bitsPerFrame;\n    total_bytes_output.total += bitsPerFrame;\n    /* round up: */\n    if (total_bytes_output.total % 8 != 0) total_bytes_output.total = 1 + total_bytes_output.total / 8;else total_bytes_output.total = total_bytes_output.total / 8;\n    total_bytes_output.total += bufByteIdx + 1;\n    if (flushbits < 0) {\n      System.err.println(\"strange error flushing buffer ... \\n\");\n    }\n    return flushbits;\n  }\n  this.flush_bitstream = function (gfp) {\n    var gfc = gfp.internal_flags;\n    var l3_side;\n    var flushbits;\n    var last_ptr = gfc.h_ptr - 1;\n    /* last header to add to bitstream */\n    if (last_ptr == -1) last_ptr = LameInternalFlags.MAX_HEADER_BUF - 1;\n    l3_side = gfc.l3_side;\n    if ((flushbits = compute_flushbits(gfp, new TotalBytes())) < 0) return;\n    drain_into_ancillary(gfp, flushbits);\n\n    /* check that the 100% of the last frame has been written to bitstream */\n    assert(gfc.header[last_ptr].write_timing + this.getframebits(gfp) == totbit);\n\n    /*\n     * we have padded out all frames with ancillary data, which is the same\n     * as filling the bitreservoir with ancillary data, so :\n     */\n    gfc.ResvSize = 0;\n    l3_side.main_data_begin = 0;\n\n    /* save the ReplayGain value */\n    if (gfc.findReplayGain) {\n      var RadioGain = ga.GetTitleGain(gfc.rgdata);\n      assert(NEQ(RadioGain, GainAnalysis.GAIN_NOT_ENOUGH_SAMPLES));\n      gfc.RadioGain = Math.floor(RadioGain * 10.0 + 0.5) | 0;\n      /* round to nearest */\n    }\n\n    /* find the gain and scale change required for no clipping */\n    if (gfc.findPeakSample) {\n      gfc.noclipGainChange = Math.ceil(Math.log10(gfc.PeakSample / 32767.0) * 20.0 * 10.0) | 0;\n      /* round up */\n\n      if (gfc.noclipGainChange > 0) {\n        /* clipping occurs */\n        if (EQ(gfp.scale, 1.0) || EQ(gfp.scale, 0.0)) gfc.noclipScale = Math.floor(32767.0 / gfc.PeakSample * 100.0) / 100.0;\n        /* round down */else {\n          /*\n           * the user specified his own scaling factor. We could\n           * suggest the scaling factor of\n           * (32767.0/gfp.PeakSample)*(gfp.scale) but it's usually\n           * very inaccurate. So we'd rather not advice him on the\n           * scaling factor.\n           */\n          gfc.noclipScale = -1;\n        }\n      } else /* no clipping */\n        gfc.noclipScale = -1;\n    }\n  };\n  this.add_dummy_byte = function (gfp, val, n) {\n    var gfc = gfp.internal_flags;\n    var i;\n    while (n-- > 0) {\n      putbits_noheaders(gfc, val, 8);\n      for (i = 0; i < LameInternalFlags.MAX_HEADER_BUF; ++i) gfc.header[i].write_timing += 8;\n    }\n  };\n\n  /**\n   * This is called after a frame of audio has been quantized and coded. It\n   * will write the encoded audio to the bitstream. Note that from a layer3\n   * encoder's perspective the bit stream is primarily a series of main_data()\n   * blocks, with header and side information inserted at the proper locations\n   * to maintain framing. (See Figure A.7 in the IS).\n   */\n  this.format_bitstream = function (gfp) {\n    var gfc = gfp.internal_flags;\n    var l3_side;\n    l3_side = gfc.l3_side;\n    var bitsPerFrame = this.getframebits(gfp);\n    drain_into_ancillary(gfp, l3_side.resvDrain_pre);\n    encodeSideInfo2(gfp, bitsPerFrame);\n    var bits = 8 * gfc.sideinfo_len;\n    bits += writeMainData(gfp);\n    drain_into_ancillary(gfp, l3_side.resvDrain_post);\n    bits += l3_side.resvDrain_post;\n    l3_side.main_data_begin += (bitsPerFrame - bits) / 8;\n\n    /*\n     * compare number of bits needed to clear all buffered mp3 frames with\n     * what we think the resvsize is:\n     */\n    if (compute_flushbits(gfp, new TotalBytes()) != gfc.ResvSize) {\n      System.err.println(\"Internal buffer inconsistency. flushbits <> ResvSize\");\n    }\n\n    /*\n     * compare main_data_begin for the next frame with what we think the\n     * resvsize is:\n     */\n    if (l3_side.main_data_begin * 8 != gfc.ResvSize) {\n      System.err.printf(\"bit reservoir error: \\n\" + \"l3_side.main_data_begin: %d \\n\" + \"Resvoir size:             %d \\n\" + \"resv drain (post)         %d \\n\" + \"resv drain (pre)          %d \\n\" + \"header and sideinfo:      %d \\n\" + \"data bits:                %d \\n\" + \"total bits:               %d (remainder: %d) \\n\" + \"bitsperframe:             %d \\n\", 8 * l3_side.main_data_begin, gfc.ResvSize, l3_side.resvDrain_post, l3_side.resvDrain_pre, 8 * gfc.sideinfo_len, bits - l3_side.resvDrain_post - 8 * gfc.sideinfo_len, bits, bits % 8, bitsPerFrame);\n      System.err.println(\"This is a fatal error.  It has several possible causes:\");\n      System.err.println(\"90%%  LAME compiled with buggy version of gcc using advanced optimizations\");\n      System.err.println(\" 9%%  Your system is overclocked\");\n      System.err.println(\" 1%%  bug in LAME encoding library\");\n      gfc.ResvSize = l3_side.main_data_begin * 8;\n    }\n    //;\n    assert(totbit % 8 == 0);\n    if (totbit > 1000000000) {\n      /*\n       * to avoid totbit overflow, (at 8h encoding at 128kbs) lets reset\n       * bit counter\n       */\n      var i;\n      for (i = 0; i < LameInternalFlags.MAX_HEADER_BUF; ++i) gfc.header[i].write_timing -= totbit;\n      totbit = 0;\n    }\n    return 0;\n  };\n\n  /**\n   * <PRE>\n   * copy data out of the internal MP3 bit buffer into a user supplied\n   *       unsigned char buffer.\n   *\n   *       mp3data=0      indicates data in buffer is an id3tags and VBR tags\n   *       mp3data=1      data is real mp3 frame data.\n   * </PRE>\n   */\n  this.copy_buffer = function (gfc, buffer, bufferPos, size, mp3data) {\n    var minimum = bufByteIdx + 1;\n    if (minimum <= 0) return 0;\n    if (size != 0 && minimum > size) {\n      /* buffer is too small */\n      return -1;\n    }\n    System.arraycopy(buf, 0, buffer, bufferPos, minimum);\n    bufByteIdx = -1;\n    bufBitIdx = 0;\n    if (mp3data != 0) {\n      var crc = new_int(1);\n      crc[0] = gfc.nMusicCRC;\n      vbr.updateMusicCRC(crc, buffer, bufferPos, minimum);\n      gfc.nMusicCRC = crc[0];\n\n      /**\n       * sum number of bytes belonging to the mp3 stream this info will be\n       * written into the Xing/LAME header for seeking\n       */\n      if (minimum > 0) {\n        gfc.VBR_seek_table.nBytesWritten += minimum;\n      }\n      if (gfc.decode_on_the_fly) {\n        /* decode the frame */\n        var pcm_buf = new_float_n([2, 1152]);\n        var mp3_in = minimum;\n        var samples_out = -1;\n        var i;\n\n        /* re-synthesis to pcm. Repeat until we get a samples_out=0 */\n        while (samples_out != 0) {\n          samples_out = mpg.hip_decode1_unclipped(gfc.hip, buffer, bufferPos, mp3_in, pcm_buf[0], pcm_buf[1]);\n          /*\n           * samples_out = 0: need more data to decode samples_out =\n           * -1: error. Lets assume 0 pcm output samples_out = number\n           * of samples output\n           */\n\n          /*\n           * set the lenght of the mp3 input buffer to zero, so that\n           * in the next iteration of the loop we will be querying\n           * mpglib about buffered data\n           */\n          mp3_in = 0;\n          if (samples_out == -1) {\n            /*\n             * error decoding. Not fatal, but might screw up the\n             * ReplayGain tag. What should we do? Ignore for now\n             */\n            samples_out = 0;\n          }\n          if (samples_out > 0) {\n            /* process the PCM data */\n\n            /*\n             * this should not be possible, and indicates we have\n             * overflown the pcm_buf buffer\n             */\n            assert(samples_out <= 1152);\n            if (gfc.findPeakSample) {\n              for (i = 0; i < samples_out; i++) {\n                if (pcm_buf[0][i] > gfc.PeakSample) gfc.PeakSample = pcm_buf[0][i];else if (-pcm_buf[0][i] > gfc.PeakSample) gfc.PeakSample = -pcm_buf[0][i];\n              }\n              if (gfc.channels_out > 1) for (i = 0; i < samples_out; i++) {\n                if (pcm_buf[1][i] > gfc.PeakSample) gfc.PeakSample = pcm_buf[1][i];else if (-pcm_buf[1][i] > gfc.PeakSample) gfc.PeakSample = -pcm_buf[1][i];\n              }\n            }\n            if (gfc.findReplayGain) if (ga.AnalyzeSamples(gfc.rgdata, pcm_buf[0], 0, pcm_buf[1], 0, samples_out, gfc.channels_out) == GainAnalysis.GAIN_ANALYSIS_ERROR) return -6;\n          }\n          /* if (samples_out>0) */\n        }\n        /* while (samples_out!=0) */\n      }\n      /* if (gfc.decode_on_the_fly) */\n    }\n    /* if (mp3data) */\n    return minimum;\n  };\n  this.init_bit_stream_w = function (gfc) {\n    buf = new_byte(Lame.LAME_MAXMP3BUFFER);\n    gfc.h_ptr = gfc.w_ptr = 0;\n    gfc.header[gfc.h_ptr].write_timing = 0;\n    bufByteIdx = -1;\n    bufBitIdx = 0;\n    totbit = 0;\n  };\n\n  // From machine.h\n}\n\nmodule.exports = BitStream;","map":{"version":3,"names":["common","require","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","Takehiro","Tables","Encoder","LameInternalFlags","BitStream","EQ","a","b","Math","abs","NEQ","Lame","self","CRC16_POLYNOMIAL","MAX_LENGTH","ga","mpg","ver","vbr","setModules","_ga","_mpg","_ver","_vbr","buf","totbit","bufByteIdx","bufBitIdx","getframebits","gfp","gfc","internal_flags","bit_rate","bitrate_index","bitrate_table","version","brate","bytes","out_samplerate","padding","putheader_bits","arraycopy","header","w_ptr","sideinfo_len","MAX_HEADER_BUF","putbits2","val","j","k","LAME_MAXMP3BUFFER","write_timing","min","putbits_noheaders","drain_into_ancillary","remainingBits","i","getLameShortVersion","length","charAt","ancillary_flag","disable_reservoir","writeheader","ptr","h_ptr","CRC_update","value","crc","CRC_writeheader","byte","encodeSideInfo2","bitsPerFrame","l3_side","gr","ch","fill","error_protection","samplerate_index","extension","mode","ordinal","mode_ext","copyright","original","emphasis","main_data_begin","channels_out","private_bits","band","scfsi","gi","tt","part2_3_length","part2_length","big_values","global_gain","scalefac_compress","block_type","NORM_TYPE","mixed_block_flag","table_select","subblock_gain","region0_count","region1_count","preflag","scalefac_scale","count1table_select","old","err","println","huffman_coder_count1","h","ht","bits","ix","xr","count1","huffbits","p","v","l3_enc","table","hlen","Huffmancode","tableindex","start","end","cbits","xbits","linbits","xlen","ext","x1","x2","linbits_x1","linmax","linbits_x2","ShortHuffmancodebits","region1Start","scalefac_band","s","LongHuffmancodebits","bigvalues","region2Start","l","writeMainData","sfb","data_bits","tot_bits","slen1","slen1_tab","slen2","slen2_tab","sfbdivide","scalefac","sfbmax","SHORT_TYPE","sfb_partition","scale_bits","sfb_partition_table","sfbs","slen","max","TotalBytes","total","compute_flushbits","total_bytes_output","flushbits","remaining_headers","last_ptr","first_ptr","flush_bitstream","ResvSize","findReplayGain","RadioGain","GetTitleGain","rgdata","GainAnalysis","GAIN_NOT_ENOUGH_SAMPLES","floor","findPeakSample","noclipGainChange","ceil","log10","PeakSample","scale","noclipScale","add_dummy_byte","n","format_bitstream","resvDrain_pre","resvDrain_post","printf","copy_buffer","buffer","bufferPos","size","mp3data","minimum","nMusicCRC","updateMusicCRC","VBR_seek_table","nBytesWritten","decode_on_the_fly","pcm_buf","mp3_in","samples_out","hip_decode1_unclipped","hip","AnalyzeSamples","GAIN_ANALYSIS_ERROR","init_bit_stream_w","module","exports"],"sources":["/Users/michaelli/Desktop/the-roast/frontend/node_modules/lamejs/src/js/BitStream.js"],"sourcesContent":["var common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Takehiro = require('./Takehiro.js');\nvar Tables = require('./Tables.js');\nvar Encoder = require('./Encoder.js');\nvar LameInternalFlags = require('./LameInternalFlags.js');\n\nBitStream.EQ = function (a, b) {\n    return (Math.abs(a) > Math.abs(b)) ? (Math.abs((a) - (b)) <= (Math\n        .abs(a) * 1e-6))\n        : (Math.abs((a) - (b)) <= (Math.abs(b) * 1e-6));\n};\n\nBitStream.NEQ = function (a, b) {\n    return !BitStream.EQ(a, b);\n};\n\nfunction BitStream() {\n    var Lame = require('./Lame.js');\n    var self = this;\n    var CRC16_POLYNOMIAL = 0x8005;\n\n    /*\n     * we work with ints, so when doing bit manipulation, we limit ourselves to\n     * MAX_LENGTH-2 just to be on the safe side\n     */\n    var MAX_LENGTH = 32;\n\n    //GainAnalysis ga;\n    //MPGLib mpg;\n    //Version ver;\n    //VBRTag vbr;\n    var ga = null;\n    var mpg = null;\n    var ver = null;\n    var vbr = null;\n\n    //public final void setModules(GainAnalysis ga, MPGLib mpg, Version ver,\n    //\tVBRTag vbr) {\n\n    this.setModules = function (_ga, _mpg, _ver, _vbr) {\n        ga = _ga;\n        mpg = _mpg;\n        ver = _ver;\n        vbr = _vbr;\n    };\n\n    /**\n     * Bit stream buffer.\n     */\n    //private byte[] buf;\n    var buf = null;\n    /**\n     * Bit counter of bit stream.\n     */\n    var totbit = 0;\n    /**\n     * Pointer to top byte in buffer.\n     */\n    var bufByteIdx = 0;\n    /**\n     * Pointer to top bit of top byte in buffer.\n     */\n    var bufBitIdx = 0;\n\n    /**\n     * compute bitsperframe and mean_bits for a layer III frame\n     */\n    this.getframebits = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var bit_rate;\n\n        /* get bitrate in kbps [?] */\n        if (gfc.bitrate_index != 0)\n            bit_rate = Tables.bitrate_table[gfp.version][gfc.bitrate_index];\n        else\n            bit_rate = gfp.brate;\n        assert(8 <= bit_rate && bit_rate <= 640);\n\n        /* main encoding routine toggles padding on and off */\n        /* one Layer3 Slot consists of 8 bits */\n        var bytes = 0 | (gfp.version + 1) * 72000 * bit_rate / gfp.out_samplerate + gfc.padding;\n        return 8 * bytes;\n    };\n\n    function putheader_bits(gfc) {\n        System.arraycopy(gfc.header[gfc.w_ptr].buf, 0, buf, bufByteIdx, gfc.sideinfo_len);\n        bufByteIdx += gfc.sideinfo_len;\n        totbit += gfc.sideinfo_len * 8;\n        gfc.w_ptr = (gfc.w_ptr + 1) & (LameInternalFlags.MAX_HEADER_BUF - 1);\n    }\n\n    /**\n     * write j bits into the bit stream\n     */\n    function putbits2(gfc, val, j) {\n        assert(j < MAX_LENGTH - 2);\n\n        while (j > 0) {\n            var k;\n            if (bufBitIdx == 0) {\n                bufBitIdx = 8;\n                bufByteIdx++;\n                assert(bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n                assert(gfc.header[gfc.w_ptr].write_timing >= totbit);\n                if (gfc.header[gfc.w_ptr].write_timing == totbit) {\n                    putheader_bits(gfc);\n                }\n                buf[bufByteIdx] = 0;\n            }\n\n            k = Math.min(j, bufBitIdx);\n            j -= k;\n\n            bufBitIdx -= k;\n\n            assert(j < MAX_LENGTH);\n            /* 32 too large on 32 bit machines */\n            assert(bufBitIdx < MAX_LENGTH);\n\n            buf[bufByteIdx] |= ((val >> j) << bufBitIdx);\n            totbit += k;\n        }\n    }\n\n    /**\n     * write j bits into the bit stream, ignoring frame headers\n     */\n    function putbits_noheaders(gfc, val, j) {\n        assert(j < MAX_LENGTH - 2);\n\n        while (j > 0) {\n            var k;\n            if (bufBitIdx == 0) {\n                bufBitIdx = 8;\n                bufByteIdx++;\n                assert(bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n                buf[bufByteIdx] = 0;\n            }\n\n            k = Math.min(j, bufBitIdx);\n            j -= k;\n\n            bufBitIdx -= k;\n\n            assert(j < MAX_LENGTH);\n            /* 32 too large on 32 bit machines */\n            assert(bufBitIdx < MAX_LENGTH);\n\n            buf[bufByteIdx] |= ((val >> j) << bufBitIdx);\n            totbit += k;\n        }\n    }\n\n    /**\n     * Some combinations of bitrate, Fs, and stereo make it impossible to stuff\n     * out a frame using just main_data, due to the limited number of bits to\n     * indicate main_data_length. In these situations, we put stuffing bits into\n     * the ancillary data...\n     */\n    function drain_into_ancillary(gfp, remainingBits) {\n        var gfc = gfp.internal_flags;\n        var i;\n        assert(remainingBits >= 0);\n\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x4c, 8);\n            remainingBits -= 8;\n        }\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x41, 8);\n            remainingBits -= 8;\n        }\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x4d, 8);\n            remainingBits -= 8;\n        }\n        if (remainingBits >= 8) {\n            putbits2(gfc, 0x45, 8);\n            remainingBits -= 8;\n        }\n\n        if (remainingBits >= 32) {\n            var version = ver.getLameShortVersion();\n            if (remainingBits >= 32)\n                for (i = 0; i < version.length && remainingBits >= 8; ++i) {\n                    remainingBits -= 8;\n                    putbits2(gfc, version.charAt(i), 8);\n                }\n        }\n\n        for (; remainingBits >= 1; remainingBits -= 1) {\n            putbits2(gfc, gfc.ancillary_flag, 1);\n            gfc.ancillary_flag ^= (!gfp.disable_reservoir ? 1 : 0);\n        }\n\n        assert(remainingBits == 0);\n\n    }\n\n    /**\n     * write N bits into the header\n     */\n    function writeheader(gfc, val, j) {\n        var ptr = gfc.header[gfc.h_ptr].ptr;\n\n        while (j > 0) {\n            var k = Math.min(j, 8 - (ptr & 7));\n            j -= k;\n            assert(j < MAX_LENGTH);\n            /* >> 32 too large for 32 bit machines */\n\n            gfc.header[gfc.h_ptr].buf[ptr >> 3] |= ((val >> j)) << (8 - (ptr & 7) - k);\n            ptr += k;\n        }\n        gfc.header[gfc.h_ptr].ptr = ptr;\n    }\n\n    function CRC_update(value, crc) {\n        value <<= 8;\n        for (var i = 0; i < 8; i++) {\n            value <<= 1;\n            crc <<= 1;\n\n            if ((((crc ^ value) & 0x10000) != 0))\n                crc ^= CRC16_POLYNOMIAL;\n        }\n        return crc;\n    }\n\n    this.CRC_writeheader = function (gfc, header) {\n        var crc = 0xffff;\n        /* (jo) init crc16 for error_protection */\n\n        crc = CRC_update(header[2] & 0xff, crc);\n        crc = CRC_update(header[3] & 0xff, crc);\n        for (var i = 6; i < gfc.sideinfo_len; i++) {\n            crc = CRC_update(header[i] & 0xff, crc);\n        }\n\n        header[4] = (byte)(crc >> 8);\n        header[5] = (byte)(crc & 255);\n    };\n\n    function encodeSideInfo2(gfp, bitsPerFrame) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        var gr, ch;\n\n        l3_side = gfc.l3_side;\n        gfc.header[gfc.h_ptr].ptr = 0;\n        Arrays.fill(gfc.header[gfc.h_ptr].buf, 0, gfc.sideinfo_len, 0);\n        if (gfp.out_samplerate < 16000)\n            writeheader(gfc, 0xffe, 12);\n        else\n            writeheader(gfc, 0xfff, 12);\n        writeheader(gfc, (gfp.version), 1);\n        writeheader(gfc, 4 - 3, 2);\n        writeheader(gfc, (!gfp.error_protection ? 1 : 0), 1);\n        writeheader(gfc, (gfc.bitrate_index), 4);\n        writeheader(gfc, (gfc.samplerate_index), 2);\n        writeheader(gfc, (gfc.padding), 1);\n        writeheader(gfc, (gfp.extension), 1);\n        writeheader(gfc, (gfp.mode.ordinal()), 2);\n        writeheader(gfc, (gfc.mode_ext), 2);\n        writeheader(gfc, (gfp.copyright), 1);\n        writeheader(gfc, (gfp.original), 1);\n        writeheader(gfc, (gfp.emphasis), 2);\n        if (gfp.error_protection) {\n            writeheader(gfc, 0, 16);\n            /* dummy */\n        }\n\n        if (gfp.version == 1) {\n            /* MPEG1 */\n            assert(l3_side.main_data_begin >= 0);\n            writeheader(gfc, (l3_side.main_data_begin), 9);\n\n            if (gfc.channels_out == 2)\n                writeheader(gfc, l3_side.private_bits, 3);\n            else\n                writeheader(gfc, l3_side.private_bits, 5);\n\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var band;\n                for (band = 0; band < 4; band++) {\n                    writeheader(gfc, l3_side.scfsi[ch][band], 1);\n                }\n            }\n\n            for (gr = 0; gr < 2; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    var gi = l3_side.tt[gr][ch];\n                    writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);\n                    writeheader(gfc, gi.big_values / 2, 9);\n                    writeheader(gfc, gi.global_gain, 8);\n                    writeheader(gfc, gi.scalefac_compress, 4);\n\n                    if (gi.block_type != Encoder.NORM_TYPE) {\n                        writeheader(gfc, 1, 1);\n                        /* window_switching_flag */\n                        writeheader(gfc, gi.block_type, 2);\n                        writeheader(gfc, gi.mixed_block_flag, 1);\n\n                        if (gi.table_select[0] == 14)\n                            gi.table_select[0] = 16;\n                        writeheader(gfc, gi.table_select[0], 5);\n                        if (gi.table_select[1] == 14)\n                            gi.table_select[1] = 16;\n                        writeheader(gfc, gi.table_select[1], 5);\n\n                        writeheader(gfc, gi.subblock_gain[0], 3);\n                        writeheader(gfc, gi.subblock_gain[1], 3);\n                        writeheader(gfc, gi.subblock_gain[2], 3);\n                    } else {\n                        writeheader(gfc, 0, 1);\n                        /* window_switching_flag */\n                        if (gi.table_select[0] == 14)\n                            gi.table_select[0] = 16;\n                        writeheader(gfc, gi.table_select[0], 5);\n                        if (gi.table_select[1] == 14)\n                            gi.table_select[1] = 16;\n                        writeheader(gfc, gi.table_select[1], 5);\n                        if (gi.table_select[2] == 14)\n                            gi.table_select[2] = 16;\n                        writeheader(gfc, gi.table_select[2], 5);\n\n                        assert(0 <= gi.region0_count && gi.region0_count < 16);\n                        assert(0 <= gi.region1_count && gi.region1_count < 8);\n                        writeheader(gfc, gi.region0_count, 4);\n                        writeheader(gfc, gi.region1_count, 3);\n                    }\n                    writeheader(gfc, gi.preflag, 1);\n                    writeheader(gfc, gi.scalefac_scale, 1);\n                    writeheader(gfc, gi.count1table_select, 1);\n                }\n            }\n        } else {\n            /* MPEG2 */\n            assert(l3_side.main_data_begin >= 0);\n            writeheader(gfc, (l3_side.main_data_begin), 8);\n            writeheader(gfc, l3_side.private_bits, gfc.channels_out);\n\n            gr = 0;\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var gi = l3_side.tt[gr][ch];\n                writeheader(gfc, gi.part2_3_length + gi.part2_length, 12);\n                writeheader(gfc, gi.big_values / 2, 9);\n                writeheader(gfc, gi.global_gain, 8);\n                writeheader(gfc, gi.scalefac_compress, 9);\n\n                if (gi.block_type != Encoder.NORM_TYPE) {\n                    writeheader(gfc, 1, 1);\n                    /* window_switching_flag */\n                    writeheader(gfc, gi.block_type, 2);\n                    writeheader(gfc, gi.mixed_block_flag, 1);\n\n                    if (gi.table_select[0] == 14)\n                        gi.table_select[0] = 16;\n                    writeheader(gfc, gi.table_select[0], 5);\n                    if (gi.table_select[1] == 14)\n                        gi.table_select[1] = 16;\n                    writeheader(gfc, gi.table_select[1], 5);\n\n                    writeheader(gfc, gi.subblock_gain[0], 3);\n                    writeheader(gfc, gi.subblock_gain[1], 3);\n                    writeheader(gfc, gi.subblock_gain[2], 3);\n                } else {\n                    writeheader(gfc, 0, 1);\n                    /* window_switching_flag */\n                    if (gi.table_select[0] == 14)\n                        gi.table_select[0] = 16;\n                    writeheader(gfc, gi.table_select[0], 5);\n                    if (gi.table_select[1] == 14)\n                        gi.table_select[1] = 16;\n                    writeheader(gfc, gi.table_select[1], 5);\n                    if (gi.table_select[2] == 14)\n                        gi.table_select[2] = 16;\n                    writeheader(gfc, gi.table_select[2], 5);\n\n                    assert(0 <= gi.region0_count && gi.region0_count < 16);\n                    assert(0 <= gi.region1_count && gi.region1_count < 8);\n                    writeheader(gfc, gi.region0_count, 4);\n                    writeheader(gfc, gi.region1_count, 3);\n                }\n\n                writeheader(gfc, gi.scalefac_scale, 1);\n                writeheader(gfc, gi.count1table_select, 1);\n            }\n        }\n\n        if (gfp.error_protection) {\n            /* (jo) error_protection: add crc16 information to header */\n            CRC_writeheader(gfc, gfc.header[gfc.h_ptr].buf);\n        }\n\n        {\n            var old = gfc.h_ptr;\n            assert(gfc.header[old].ptr == gfc.sideinfo_len * 8);\n\n            gfc.h_ptr = (old + 1) & (LameInternalFlags.MAX_HEADER_BUF - 1);\n            gfc.header[gfc.h_ptr].write_timing = gfc.header[old].write_timing\n                + bitsPerFrame;\n\n            if (gfc.h_ptr == gfc.w_ptr) {\n                /* yikes! we are out of header buffer space */\n                System.err\n                    .println(\"Error: MAX_HEADER_BUF too small in bitstream.c \\n\");\n            }\n\n        }\n    }\n\n    function huffman_coder_count1(gfc, gi) {\n        /* Write count1 area */\n        var h = Tables.ht[gi.count1table_select + 32];\n        var i, bits = 0;\n\n        var ix = gi.big_values;\n        var xr = gi.big_values;\n        assert(gi.count1table_select < 2);\n\n        for (i = (gi.count1 - gi.big_values) / 4; i > 0; --i) {\n            var huffbits = 0;\n            var p = 0, v;\n\n            v = gi.l3_enc[ix + 0];\n            if (v != 0) {\n                p += 8;\n                if (gi.xr[xr + 0] < 0)\n                    huffbits++;\n                assert(v <= 1);\n            }\n\n            v = gi.l3_enc[ix + 1];\n            if (v != 0) {\n                p += 4;\n                huffbits *= 2;\n                if (gi.xr[xr + 1] < 0)\n                    huffbits++;\n                assert(v <= 1);\n            }\n\n            v = gi.l3_enc[ix + 2];\n            if (v != 0) {\n                p += 2;\n                huffbits *= 2;\n                if (gi.xr[xr + 2] < 0)\n                    huffbits++;\n                assert(v <= 1);\n            }\n\n            v = gi.l3_enc[ix + 3];\n            if (v != 0) {\n                p++;\n                huffbits *= 2;\n                if (gi.xr[xr + 3] < 0)\n                    huffbits++;\n                assert(v <= 1);\n            }\n\n            ix += 4;\n            xr += 4;\n            putbits2(gfc, huffbits + h.table[p], h.hlen[p]);\n            bits += h.hlen[p];\n        }\n        return bits;\n    }\n\n    /**\n     * Implements the pseudocode of page 98 of the IS\n     */\n    function Huffmancode(gfc, tableindex, start, end, gi) {\n        var h = Tables.ht[tableindex];\n        var bits = 0;\n\n        assert(tableindex < 32);\n        if (0 == tableindex)\n            return bits;\n\n        for (var i = start; i < end; i += 2) {\n            var cbits = 0;\n            var xbits = 0;\n            var linbits = h.xlen;\n            var xlen = h.xlen;\n            var ext = 0;\n            var x1 = gi.l3_enc[i];\n            var x2 = gi.l3_enc[i + 1];\n\n            if (x1 != 0) {\n                if (gi.xr[i] < 0)\n                    ext++;\n                cbits--;\n            }\n\n            if (tableindex > 15) {\n                /* use ESC-words */\n                if (x1 > 14) {\n                    var linbits_x1 = x1 - 15;\n                    assert(linbits_x1 <= h.linmax);\n                    ext |= linbits_x1 << 1;\n                    xbits = linbits;\n                    x1 = 15;\n                }\n\n                if (x2 > 14) {\n                    var linbits_x2 = x2 - 15;\n                    assert(linbits_x2 <= h.linmax);\n                    ext <<= linbits;\n                    ext |= linbits_x2;\n                    xbits += linbits;\n                    x2 = 15;\n                }\n                xlen = 16;\n            }\n\n            if (x2 != 0) {\n                ext <<= 1;\n                if (gi.xr[i + 1] < 0)\n                    ext++;\n                cbits--;\n            }\n\n            assert((x1 | x2) < 16);\n\n            x1 = x1 * xlen + x2;\n            xbits -= cbits;\n            cbits += h.hlen[x1];\n\n            assert(cbits <= MAX_LENGTH);\n            assert(xbits <= MAX_LENGTH);\n\n            putbits2(gfc, h.table[x1], cbits);\n            putbits2(gfc, ext, xbits);\n            bits += cbits + xbits;\n        }\n        return bits;\n    }\n\n    /**\n     * Note the discussion of huffmancodebits() on pages 28 and 29 of the IS, as\n     * well as the definitions of the side information on pages 26 and 27.\n     */\n    function ShortHuffmancodebits(gfc, gi) {\n        var region1Start = 3 * gfc.scalefac_band.s[3];\n        if (region1Start > gi.big_values)\n            region1Start = gi.big_values;\n\n        /* short blocks do not have a region2 */\n        var bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);\n        bits += Huffmancode(gfc, gi.table_select[1], region1Start,\n            gi.big_values, gi);\n        return bits;\n    }\n\n    function LongHuffmancodebits(gfc, gi) {\n        var bigvalues, bits;\n        var region1Start, region2Start;\n\n        bigvalues = gi.big_values;\n        assert(0 <= bigvalues && bigvalues <= 576);\n\n        var i = gi.region0_count + 1;\n        assert(0 <= i);\n        assert(i < gfc.scalefac_band.l.length);\n        region1Start = gfc.scalefac_band.l[i];\n        i += gi.region1_count + 1;\n        assert(0 <= i);\n        assert(i < gfc.scalefac_band.l.length);\n        region2Start = gfc.scalefac_band.l[i];\n\n        if (region1Start > bigvalues)\n            region1Start = bigvalues;\n\n        if (region2Start > bigvalues)\n            region2Start = bigvalues;\n\n        bits = Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);\n        bits += Huffmancode(gfc, gi.table_select[1], region1Start,\n            region2Start, gi);\n        bits += Huffmancode(gfc, gi.table_select[2], region2Start, bigvalues,\n            gi);\n        return bits;\n    }\n\n    function writeMainData(gfp) {\n        var gr, ch, sfb, data_bits, tot_bits = 0;\n        var gfc = gfp.internal_flags;\n        var l3_side = gfc.l3_side;\n\n        if (gfp.version == 1) {\n            /* MPEG 1 */\n            for (gr = 0; gr < 2; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    var gi = l3_side.tt[gr][ch];\n                    var slen1 = Takehiro.slen1_tab[gi.scalefac_compress];\n                    var slen2 = Takehiro.slen2_tab[gi.scalefac_compress];\n                    data_bits = 0;\n                    for (sfb = 0; sfb < gi.sfbdivide; sfb++) {\n                        if (gi.scalefac[sfb] == -1)\n                            continue;\n                        /* scfsi is used */\n                        putbits2(gfc, gi.scalefac[sfb], slen1);\n                        data_bits += slen1;\n                    }\n                    for (; sfb < gi.sfbmax; sfb++) {\n                        if (gi.scalefac[sfb] == -1)\n                            continue;\n                        /* scfsi is used */\n                        putbits2(gfc, gi.scalefac[sfb], slen2);\n                        data_bits += slen2;\n                    }\n                    assert(data_bits == gi.part2_length);\n\n                    if (gi.block_type == Encoder.SHORT_TYPE) {\n                        data_bits += ShortHuffmancodebits(gfc, gi);\n                    } else {\n                        data_bits += LongHuffmancodebits(gfc, gi);\n                    }\n                    data_bits += huffman_coder_count1(gfc, gi);\n                    /* does bitcount in quantize.c agree with actual bit count? */\n                    assert(data_bits == gi.part2_3_length + gi.part2_length);\n                    tot_bits += data_bits;\n                }\n                /* for ch */\n            }\n            /* for gr */\n        } else {\n            /* MPEG 2 */\n            gr = 0;\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var gi = l3_side.tt[gr][ch];\n                var i, sfb_partition, scale_bits = 0;\n                assert(gi.sfb_partition_table != null);\n                data_bits = 0;\n                sfb = 0;\n                sfb_partition = 0;\n\n                if (gi.block_type == Encoder.SHORT_TYPE) {\n                    for (; sfb_partition < 4; sfb_partition++) {\n                        var sfbs = gi.sfb_partition_table[sfb_partition] / 3;\n                        var slen = gi.slen[sfb_partition];\n                        for (i = 0; i < sfbs; i++, sfb++) {\n                            putbits2(gfc,\n                                Math.max(gi.scalefac[sfb * 3 + 0], 0), slen);\n                            putbits2(gfc,\n                                Math.max(gi.scalefac[sfb * 3 + 1], 0), slen);\n                            putbits2(gfc,\n                                Math.max(gi.scalefac[sfb * 3 + 2], 0), slen);\n                            scale_bits += 3 * slen;\n                        }\n                    }\n                    data_bits += ShortHuffmancodebits(gfc, gi);\n                } else {\n                    for (; sfb_partition < 4; sfb_partition++) {\n                        var sfbs = gi.sfb_partition_table[sfb_partition];\n                        var slen = gi.slen[sfb_partition];\n                        for (i = 0; i < sfbs; i++, sfb++) {\n                            putbits2(gfc, Math.max(gi.scalefac[sfb], 0), slen);\n                            scale_bits += slen;\n                        }\n                    }\n                    data_bits += LongHuffmancodebits(gfc, gi);\n                }\n                data_bits += huffman_coder_count1(gfc, gi);\n                /* does bitcount in quantize.c agree with actual bit count? */\n                assert(data_bits == gi.part2_3_length);\n                assert(scale_bits == gi.part2_length);\n                tot_bits += scale_bits + data_bits;\n            }\n            /* for ch */\n        }\n        /* for gf */\n        return tot_bits;\n    }\n\n    /* main_data */\n\n    function TotalBytes() {\n        this.total = 0;\n    }\n\n    /*\n     * compute the number of bits required to flush all mp3 frames currently in\n     * the buffer. This should be the same as the reservoir size. Only call this\n     * routine between frames - i.e. only after all headers and data have been\n     * added to the buffer by format_bitstream().\n     *\n     * Also compute total_bits_output = size of mp3 buffer (including frame\n     * headers which may not have yet been send to the mp3 buffer) + number of\n     * bits needed to flush all mp3 frames.\n     *\n     * total_bytes_output is the size of the mp3 output buffer if\n     * lame_encode_flush_nogap() was called right now.\n     */\n    function compute_flushbits(gfp, total_bytes_output) {\n        var gfc = gfp.internal_flags;\n        var flushbits, remaining_headers;\n        var bitsPerFrame;\n        var last_ptr, first_ptr;\n        first_ptr = gfc.w_ptr;\n        /* first header to add to bitstream */\n        last_ptr = gfc.h_ptr - 1;\n        /* last header to add to bitstream */\n        if (last_ptr == -1)\n            last_ptr = LameInternalFlags.MAX_HEADER_BUF - 1;\n\n        /* add this many bits to bitstream so we can flush all headers */\n        flushbits = gfc.header[last_ptr].write_timing - totbit;\n        total_bytes_output.total = flushbits;\n\n        if (flushbits >= 0) {\n            /* if flushbits >= 0, some headers have not yet been written */\n            /* reduce flushbits by the size of the headers */\n            remaining_headers = 1 + last_ptr - first_ptr;\n            if (last_ptr < first_ptr)\n                remaining_headers = 1 + last_ptr - first_ptr\n                    + LameInternalFlags.MAX_HEADER_BUF;\n            flushbits -= remaining_headers * 8 * gfc.sideinfo_len;\n        }\n\n        /*\n         * finally, add some bits so that the last frame is complete these bits\n         * are not necessary to decode the last frame, but some decoders will\n         * ignore last frame if these bits are missing\n         */\n        bitsPerFrame = self.getframebits(gfp);\n        flushbits += bitsPerFrame;\n        total_bytes_output.total += bitsPerFrame;\n        /* round up: */\n        if ((total_bytes_output.total % 8) != 0)\n            total_bytes_output.total = 1 + (total_bytes_output.total / 8);\n        else\n            total_bytes_output.total = (total_bytes_output.total / 8);\n        total_bytes_output.total += bufByteIdx + 1;\n\n        if (flushbits < 0) {\n            System.err.println(\"strange error flushing buffer ... \\n\");\n        }\n        return flushbits;\n    }\n\n    this.flush_bitstream = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        var flushbits;\n        var last_ptr = gfc.h_ptr - 1;\n        /* last header to add to bitstream */\n        if (last_ptr == -1)\n            last_ptr = LameInternalFlags.MAX_HEADER_BUF - 1;\n        l3_side = gfc.l3_side;\n\n        if ((flushbits = compute_flushbits(gfp, new TotalBytes())) < 0)\n            return;\n        drain_into_ancillary(gfp, flushbits);\n\n        /* check that the 100% of the last frame has been written to bitstream */\n        assert(gfc.header[last_ptr].write_timing + this.getframebits(gfp) == totbit);\n\n        /*\n         * we have padded out all frames with ancillary data, which is the same\n         * as filling the bitreservoir with ancillary data, so :\n         */\n        gfc.ResvSize = 0;\n        l3_side.main_data_begin = 0;\n\n        /* save the ReplayGain value */\n        if (gfc.findReplayGain) {\n            var RadioGain = ga.GetTitleGain(gfc.rgdata);\n            assert(NEQ(RadioGain, GainAnalysis.GAIN_NOT_ENOUGH_SAMPLES));\n            gfc.RadioGain = Math.floor(RadioGain * 10.0 + 0.5) | 0;\n            /* round to nearest */\n        }\n\n        /* find the gain and scale change required for no clipping */\n        if (gfc.findPeakSample) {\n            gfc.noclipGainChange = Math.ceil(Math\n                        .log10(gfc.PeakSample / 32767.0) * 20.0 * 10.0) | 0;\n            /* round up */\n\n            if (gfc.noclipGainChange > 0) {\n                /* clipping occurs */\n                if (EQ(gfp.scale, 1.0) || EQ(gfp.scale, 0.0))\n                    gfc.noclipScale = (Math\n                        .floor((32767.0 / gfc.PeakSample) * 100.0) / 100.0);\n                /* round down */\n                else {\n                    /*\n                     * the user specified his own scaling factor. We could\n                     * suggest the scaling factor of\n                     * (32767.0/gfp.PeakSample)*(gfp.scale) but it's usually\n                     * very inaccurate. So we'd rather not advice him on the\n                     * scaling factor.\n                     */\n                    gfc.noclipScale = -1;\n                }\n            } else\n            /* no clipping */\n                gfc.noclipScale = -1;\n        }\n    };\n\n    this.add_dummy_byte = function (gfp, val, n) {\n        var gfc = gfp.internal_flags;\n        var i;\n\n        while (n-- > 0) {\n            putbits_noheaders(gfc, val, 8);\n\n            for (i = 0; i < LameInternalFlags.MAX_HEADER_BUF; ++i)\n                gfc.header[i].write_timing += 8;\n        }\n    };\n\n    /**\n     * This is called after a frame of audio has been quantized and coded. It\n     * will write the encoded audio to the bitstream. Note that from a layer3\n     * encoder's perspective the bit stream is primarily a series of main_data()\n     * blocks, with header and side information inserted at the proper locations\n     * to maintain framing. (See Figure A.7 in the IS).\n     */\n    this.format_bitstream = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        l3_side = gfc.l3_side;\n\n        var bitsPerFrame = this.getframebits(gfp);\n        drain_into_ancillary(gfp, l3_side.resvDrain_pre);\n\n        encodeSideInfo2(gfp, bitsPerFrame);\n        var bits = 8 * gfc.sideinfo_len;\n        bits += writeMainData(gfp);\n        drain_into_ancillary(gfp, l3_side.resvDrain_post);\n        bits += l3_side.resvDrain_post;\n\n        l3_side.main_data_begin += (bitsPerFrame - bits) / 8;\n\n        /*\n         * compare number of bits needed to clear all buffered mp3 frames with\n         * what we think the resvsize is:\n         */\n        if (compute_flushbits(gfp, new TotalBytes()) != gfc.ResvSize) {\n            System.err.println(\"Internal buffer inconsistency. flushbits <> ResvSize\");\n        }\n\n        /*\n         * compare main_data_begin for the next frame with what we think the\n         * resvsize is:\n         */\n        if ((l3_side.main_data_begin * 8) != gfc.ResvSize) {\n            System.err.printf(\"bit reservoir error: \\n\"\n                + \"l3_side.main_data_begin: %d \\n\"\n                + \"Resvoir size:             %d \\n\"\n                + \"resv drain (post)         %d \\n\"\n                + \"resv drain (pre)          %d \\n\"\n                + \"header and sideinfo:      %d \\n\"\n                + \"data bits:                %d \\n\"\n                + \"total bits:               %d (remainder: %d) \\n\"\n                + \"bitsperframe:             %d \\n\",\n                8 * l3_side.main_data_begin, gfc.ResvSize,\n                l3_side.resvDrain_post, l3_side.resvDrain_pre,\n                8 * gfc.sideinfo_len, bits - l3_side.resvDrain_post - 8\n                * gfc.sideinfo_len, bits, bits % 8, bitsPerFrame);\n\n            System.err.println(\"This is a fatal error.  It has several possible causes:\");\n            System.err.println(\"90%%  LAME compiled with buggy version of gcc using advanced optimizations\");\n            System.err.println(\" 9%%  Your system is overclocked\");\n            System.err.println(\" 1%%  bug in LAME encoding library\");\n\n            gfc.ResvSize = l3_side.main_data_begin * 8;\n        }\n        //;\n        assert(totbit % 8 == 0);\n\n        if (totbit > 1000000000) {\n            /*\n             * to avoid totbit overflow, (at 8h encoding at 128kbs) lets reset\n             * bit counter\n             */\n            var i;\n            for (i = 0; i < LameInternalFlags.MAX_HEADER_BUF; ++i)\n                gfc.header[i].write_timing -= totbit;\n            totbit = 0;\n        }\n\n        return 0;\n    };\n\n    /**\n     * <PRE>\n     * copy data out of the internal MP3 bit buffer into a user supplied\n     *       unsigned char buffer.\n     *\n     *       mp3data=0      indicates data in buffer is an id3tags and VBR tags\n     *       mp3data=1      data is real mp3 frame data.\n     * </PRE>\n     */\n    this.copy_buffer = function (gfc, buffer, bufferPos, size, mp3data) {\n        var minimum = bufByteIdx + 1;\n        if (minimum <= 0)\n            return 0;\n        if (size != 0 && minimum > size) {\n            /* buffer is too small */\n            return -1;\n        }\n        System.arraycopy(buf, 0, buffer, bufferPos, minimum);\n        bufByteIdx = -1;\n        bufBitIdx = 0;\n\n        if (mp3data != 0) {\n            var crc = new_int(1);\n            crc[0] = gfc.nMusicCRC;\n            vbr.updateMusicCRC(crc, buffer, bufferPos, minimum);\n            gfc.nMusicCRC = crc[0];\n\n            /**\n             * sum number of bytes belonging to the mp3 stream this info will be\n             * written into the Xing/LAME header for seeking\n             */\n            if (minimum > 0) {\n                gfc.VBR_seek_table.nBytesWritten += minimum;\n            }\n\n            if (gfc.decode_on_the_fly) { /* decode the frame */\n                var pcm_buf = new_float_n([2, 1152]);\n                var mp3_in = minimum;\n                var samples_out = -1;\n                var i;\n\n                /* re-synthesis to pcm. Repeat until we get a samples_out=0 */\n                while (samples_out != 0) {\n\n                    samples_out = mpg.hip_decode1_unclipped(gfc.hip, buffer,\n                        bufferPos, mp3_in, pcm_buf[0], pcm_buf[1]);\n                    /*\n                     * samples_out = 0: need more data to decode samples_out =\n                     * -1: error. Lets assume 0 pcm output samples_out = number\n                     * of samples output\n                     */\n\n                    /*\n                     * set the lenght of the mp3 input buffer to zero, so that\n                     * in the next iteration of the loop we will be querying\n                     * mpglib about buffered data\n                     */\n                    mp3_in = 0;\n\n                    if (samples_out == -1) {\n                        /*\n                         * error decoding. Not fatal, but might screw up the\n                         * ReplayGain tag. What should we do? Ignore for now\n                         */\n                        samples_out = 0;\n                    }\n                    if (samples_out > 0) {\n                        /* process the PCM data */\n\n                        /*\n                         * this should not be possible, and indicates we have\n                         * overflown the pcm_buf buffer\n                         */\n                        assert(samples_out <= 1152);\n\n                        if (gfc.findPeakSample) {\n                            for (i = 0; i < samples_out; i++) {\n                                if (pcm_buf[0][i] > gfc.PeakSample)\n                                    gfc.PeakSample = pcm_buf[0][i];\n                                else if (-pcm_buf[0][i] > gfc.PeakSample)\n                                    gfc.PeakSample = -pcm_buf[0][i];\n                            }\n                            if (gfc.channels_out > 1)\n                                for (i = 0; i < samples_out; i++) {\n                                    if (pcm_buf[1][i] > gfc.PeakSample)\n                                        gfc.PeakSample = pcm_buf[1][i];\n                                    else if (-pcm_buf[1][i] > gfc.PeakSample)\n                                        gfc.PeakSample = -pcm_buf[1][i];\n                                }\n                        }\n\n                        if (gfc.findReplayGain)\n                            if (ga.AnalyzeSamples(gfc.rgdata, pcm_buf[0], 0,\n                                    pcm_buf[1], 0, samples_out,\n                                    gfc.channels_out) == GainAnalysis.GAIN_ANALYSIS_ERROR)\n                                return -6;\n\n                    }\n                    /* if (samples_out>0) */\n                }\n                /* while (samples_out!=0) */\n            }\n            /* if (gfc.decode_on_the_fly) */\n\n        }\n        /* if (mp3data) */\n        return minimum;\n    };\n\n    this.init_bit_stream_w = function (gfc) {\n        buf = new_byte(Lame.LAME_MAXMP3BUFFER);\n\n        gfc.h_ptr = gfc.w_ptr = 0;\n        gfc.header[gfc.h_ptr].write_timing = 0;\n        bufByteIdx = -1;\n        bufBitIdx = 0;\n        totbit = 0;\n    };\n\n    // From machine.h\n\n\n}\n\nmodule.exports = BitStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}